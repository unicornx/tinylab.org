---
layout: post
draft: true
author: 'Wang Chen'
title: "LWN 780556: xxxx"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-780556/
description: "LWN 中文翻译，xxxx"
category:
  - 进程调度
  - LWN
tags:
  - Linux
  - realtime
---

**请点击 [LWN 中文翻译计划](/lwn)，了解更多详情。**

> 原文：[Reimplementing printk()](https://lwn.net/Articles/780556/)
> 原创：By Jake Edge @ Feb. 26, 2019
> 翻译：By [unicornx](https://github.com/unicornx)
> 校对：By [xxx](https://github.com/xxx)

> The venerable `printk()` function has been part of Linux since the very beginning, though it has undergone a fair number of changes along the way. Now, John Ogness is proposing to fundamentally rework `printk()` in order to get rid of handful of issues that currently plague it. The proposed code does this by adding yet another ring-buffer implementation to the kernel; this one is aimed at making `printk()` work better from hard-to-handle contexts. For a task that seems conceptually simple—printing messages to the console—`printk()` is actually a rather complex beast; that won't change if these patches are merged, though many of the problems with the current implementation will be removed.

古老的printk（）函数从一开始就是Linux的一部分，尽管它在此过程中经历了相当多的变化。现在，John Ogness建议从根本上改造printk（），以摆脱目前困扰它的一些问题。建议的代码通过向内核添加另一个环形缓冲区实现来实现这一点; 这一个旨在使printk（）从难以处理的上下文中更好地工作。对于一个看起来概念简单的任务 - 打印到console- printk（）的消息实际上是一个相当复杂的野兽; 如果合并这些补丁，这将不会改变，尽管将删除当前实现的许多问题。

> In the [cover letter](https://lwn.net/ml/linux-kernel/20190212143003.48446-1-john.ogness@linutronix.de/) of his RFC patch set, Ogness lays out seven problems that he sees with the current `printk()` implementation. The buffer used by `printk()` is protected by a raw spinlock, which restricts the contexts from which the buffer can be accessed. Calling `printk()` from a non-maskable interrupt (NMI) or a recursive context, where something called from `printk()` also calls `printk()`, currently means that the logging of the message is deferred, which could cause the message to be lost. Printing to slow consoles can result in large latencies, a `printk()` call may end up taking unbounded time while other deferred messages are printed ahead of the one the caller actually wanted to print.

在他的RFC补丁集的求职信中，Ogness列出了他在当前的printk（） 实现中看到的七个问题。printk（）使用的缓冲区受原始自旋锁保护，原始自旋锁限制了可以从中访问缓冲区的上下文。调用的printk（）从非屏蔽中断（NMI）或递归的背景下，来自被称为东西的printk（）还调用的printk（） ，目前是指消息的记录被推迟，这可能导致丢失邮件。打印到缓慢的控制台可能导致大的延迟，printk（） 呼叫可能最终占用无限时间，而其他延迟消息在呼叫者实际想要打印之前打印。

> Two other problems are identified by Ogness. Timestamps on the messages are added when a message is added to the buffer but, due to deferrals, that can happen well after the `printk()` call was made. While that behavior has the side effect of nicely sorting the messages in terms of time, it is "`neither accurate nor reliable`". In addition, because `printk()` tries to satisfy all of its users, it ends up compromising too much:

Ogness确定了另外两个问题。将消息添加到缓冲区时会添加消息的时间戳，但由于延迟，可能会在进行printk（）调用后很快发生。虽然这种行为具有在时间上很好地对消息进行排序的副作用，但它“ 既不准确也不可靠 ”。另外，因为printk（） 试图满足它的所有用户，所以它最终会妥协：

>     Loglevel INFO is handled the same as ERR. There seems to be an endless effort to get printk to show _all_ messages as quickly as possible in case of a panic (i.e. printing from any context), but at the same time try not to have printk be too intrusive for the callers. These are conflicting requirements that lead to a printk implementation that does a sub-optimal job of satisfying both sides.

    Loglevel INFO的处理方式与ERR相同。在恐慌的情况下（即从任何上下文打印），似乎有无尽的努力让printk尽快显示_all_消息，但同时尽量不要让printk对调用者过于干扰。这些是相互冲突的要求，导致printk实现完成满足双方的次优工作。

> In order to fix those problems, he is proposing the addition of a kernel-internal `printk()` ring buffer that allows for multiple lockless readers; writers use a per-CPU synchronization mechanism that works in any context. This ring-buffer implementation was inspired by a [suggestion from Peter Zijlstra](https://lwn.net/ml/linux-kernel/20181017140044.GK3121%40hirez.programming.kicks-ass.net/), Ogness said. The actual writing of the messages is moved to a dedicated kernel thread, which is preemptible, so the latencies can be bounded. The new ring buffer will be allocated in the initialized data segment of the kernel, so it will be available early in the boot process, even before the memory-management subsystem is available. Timestamps will be generated early in the `printk()` function.

为了解决这些问题，他建议增加一个内核内部的 printk（）环形缓冲区，允许多个无锁读取器; 编写器使用适用于任何上下文的每CPU同步机制。Ogness说，这种环形缓冲器的实现受到了Peter Zijlstra的建议的启发。消息的实际写入被移动到一个可抢占的专用内核线程，因此延迟可以是有限的。新的环形缓冲区将分配在内核的初始化数据段中，因此即使在内存管理子系统可用之前，它也将在引导过程的早期可用。时间戳将在printk（）函数的早期生成。

> Beyond that, a new kind of "emergency message" is defined. Those messages will appear on certain consoles immediately; no waiting for any other `printk()` messages that are queued up for the kernel thread. In order to participate, consoles will need to implement the new `write_atomic(` operation. The patch set includes an [implementation of `write_atomic()` for the 8250 UART driver](https://lwn.net/ml/linux-kernel/20190212143003.48446-21-john.ogness@linutronix.de/). There is a new kernel configuration parameter, `CONFIG_LOGLEVEL_EMERGENCY`, which sets the lowest log-level value for emergency messages; it defaults to `LOG_WARNING`. That value can also be set by the "`emergency_loglevel=`" kernel command-line parameter at boot time.

除此之外，还定义了一种新的“紧急信息”。这些消息将立即出现在某些控制台上; 无需等待排队等待内核线程的任何其他 printk（）消息。为了参与，控制台将需要实现新的 write_atomic（）操作。补丁集包括8250 UART驱动程序的write_atomic（）实现。有一个新的内核配置参数CONFIG_LOGLEVEL_EMERGENCY，它为紧急消息设置最低的日志级别值; 它默认为 LOG_WARNING。该值也可以在启动时由“ emergency_loglevel = ”内核命令行参数设置。

> So instead of trying to ensure that all messages go out as quickly as possible, the proposal would effectively partition `printk()` messages into two buckets—at least for consoles that implement `write_atomic()`. Regular messages will be written out by the kernel thread, which gets scheduled and preempted normally, so it may not be flushing all of the messages right away. The messages at the emergency level and above will go out immediately to an emergency console. As he [noted](https://lwn.net/ml/linux-kernel/87d0nv248b.fsf@linutronix.de/) in the thread, there are options if losing regular messages in a crash becomes a problem:

因此，该提案不会试图确保所有消息尽快消失，而是有效地将printk（） 消息分成两个桶 - 至少对于实现write_atomic（）的控制台而言。内核线程会写出常规消息，这些消息会被正常调度和抢占，因此它可能不会立即刷新所有消息。紧急级别及以上的消息将立即发送到紧急控制台。正如他在线程中所指出的，如果在崩溃中丢失常规消息成为问题，则有一些选项：

>     As long as all critical messages are print directly and immediately to an emergency console, why is it is problem if the informational messages to consoles are sometimes delayed or lost? And if those informational messages _are_ so important, there are things the user can do. For example, create a realtime userspace task to read /dev/kmsg.

    只要所有关键信息都直接打印到紧急控制台，如果控制台的信息性消息有时会延迟或丢失，为什么会出现问题呢？如果这些信息性消息非常重要，那么用户可以做些事情。例如，创建一个实时用户空间任务来读取/ dev / kmsg。

> There are some downsides and open issues in the proposal, which Ogness also lists. The output from `printk()` has changed somewhat, which may have unforeseen consequences. A CPU ID will be printed as part of emergency messages to help disambiguate multiple simultaneous messages; those messages are separated from regular `printk()` messages using a newline character, though there may be an option added to make them stand out more. In addition:

Ogness还列出了提案中的一些缺点和未解决的问题。printk（）的输出有所改变，可能会产生无法预料的后果。将打印CPU ID作为紧急消息的一部分，以帮助消除多个同时消息的歧义; 这些消息使用换行符与常规的printk（）消息分开，但可能会添加一个选项以使它们更突出。此外：

>     Be aware that printk output is no longer time-sorted. Actually, it never was, but now you see the real timestamps. This seems strange at first.

    请注意，printk输出不再按时间排序。实际上，它从来没有，但现在你看到了真正的时间戳。起初这看起来很奇怪。

> More details on the ring buffer and its API, along with some early performance numbers, can be seen in a [patch](https://lwn.net/ml/linux-kernel/20190212143003.48446-2-john.ogness@linutronix.de/) adding a file to the `Documentation` directory.

有关环形缓冲区及其API的更多详细信息以及一些早期性能数据，可以在 将文件添加到Documentation目录的补丁中看到。

> The reaction to the patch set has been positive overall; there have been the usual questions and comments, of course. `printk()` has been the subject of two relatively recent Kernel Summit sessions ([in 2016](https://lwn.net/Articles/705938/) and [2017](https://lwn.net/Articles/737822/)); two of those proposing `printk()` changes at the summits, Sergey Senozhatsky and Petr Mladek, have also commented on the patches. Mladek had suggestions for improvements to the ring-buffer code, [as did Linus Torvalds](https://lwn.net/ml/linux-kernel/CAHk-=whToBNHN_X_BQkO4zSyhSBaGqTH8XEtxg2_AxoBdDnEdg@mail.gmail.com/). There have been no major complaints about the overall goal and plan, however, so it would seem that we could see these changes go into the mainline in a development cycle or two.

整个补丁集的反应是积极的; 当然，有一些常见的问题和评论。 printk（） 已经成为两个相对较新的内核峰会（2016年和2017年）的主题; 在峰会上提出printk（）变化的其中两位，Sergey Senozhatsky和Petr Mladek，也对这些补丁发表了评论。正如Linus Torvalds所做的那样，Mladek提出了改进环形缓冲区代码的建议。然而，对总体目标和计划没有任何重大抱怨，因此看起来我们可以看到这些变化在一两个开发周期中进入主线。

**请点击 [LWN 中文翻译计划](/lwn)，了解更多详情。**

[1]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0a0337e0d1d134465778a16f5cbea95086e8e9e0
[2]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=aac453635549699c13a84ea1456d5b0e574ef855
[3]: https://kernelnewbies.org/Linux_4.6#Improve_the_reliability_of_the_Out_Of_Memory_task_killer
[4]: https://lwn.net/Articles/668133/
[5]: https://lwn.net/Articles/627419/
[6]: https://lwn.net/Articles/666024/
