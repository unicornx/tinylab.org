---
layout: post
author: 'Wang Chen'
title: "LWN 229984: SLUB 分配器"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-229984-slub-allocator/
description: "LWN 文章翻译，SLUB 分配器"
category:
  - 内存子系统
  - LWN
tags:
  - Linux
  - memory
---

> 原文：[The SLUB allocator](https://lwn.net/Articles/229984/)
> 原创：By corbet @ Apr. 11, 2007
> 翻译：By [unicornx](https://github.com/unicornx) of [TinyLab.org][1]
> 校对：By [xxx](https://github.com/xx)

> The slab allocator has been at the core of the kernel's memory management for many years. This allocator (sitting on top of the low-level page allocator) manages caches of objects of a specific size, allowing for fast and space-efficient allocations. Kernel hackers tend not to wander into the slab code because it's complex and because, for the most part, it works quite well.

slab 分配器（slab allocator，译者注，“slab” 的含义来自于英语中的 “石板” 的概念）多年来一直是内核中内存管理子系统的核心模块。该分配器（位于底层基于页框的分配器之上）对特定大小的内存对象的分配和回收进行管理并提供高速缓存，供使用者对其快速的访问，同时节省了内存的空间（译者注，考虑一下如果没有 slab 分配器，只基于底层的页框分配机制，我们对任何一个不大于页框大小（譬如 4K）的内存请求，都只能按最小 4K 大小分配内存那会是多么浪费的一件事情）。内核开发人员一般不会尝试去修改 slab 的相关代码，一来是因为它的确很复杂，二来也是因为在大多数情况下，它运行得很好。

> Christoph Lameter is one of those people for whom the slab allocator does not work quite so well. Over time, he has come up with a list of complaints that is getting impressively long. The slab allocator maintains a number of queues of objects; these queues can make allocation fast but they also add quite a bit of complexity. Beyond that, the storage overhead tends to grow with the size of the system:

但再好的东西也会有人发现它的缺点，Christoph Lameter 就是这么一位内核极客。在使用过程中，他总结了一份令人印象深刻的问题清单。其中最值得大家关注的是，slab 分配器维护了许多保存对象的队列；这些队列可以加速对象的分配，但也带来了诸多复杂性。除此之外，随着系统的规模变大，slab 分配器消耗的内存开销也趋于变大，以下摘录了 Christoph Lameter 总结的问题描述：

> 	SLAB Object queues exist per node, per CPU. The alien cache queue even has a queue array that contain a queue for each processor on each node. For very large systems the number of queues and the number of objects that may be caught in those queues grows exponentially. On our systems with 1k nodes / processors we have several gigabytes just tied up for storing references to objects for those queues This does not include the objects that could be on those queues. One fears that the whole memory of the machine could one day be consumed by those queues.

	每个节点（node，译者注，[NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access) 的概念）中的每个 CPU 使用队列管理自己的 SLAB 对象。外部节点的缓存（alien cache queue）中甚至保存了一个队列数组，对每个外部节点上的每个处理器也都维护了一个队列。对于一个规模巨大的系统，队列的数量和可能保存在这些队列中的对象的数量呈指数增长。在我们的具有 1000 个节点或者同等规模处理器数量的系统上，我们光为了保存这些队列中对对象的引用就需要耗费掉几千兆字节。这还不包括用于存储实际对象的空间。人们担心机器的整个存储空间总有一天会被这些队列消耗殆尽。

> Beyond that, each slab (a group of one or more continuous pages from which objects are allocated) contains a chunk of metadata at the beginning which makes alignment of objects harder. The code for cleaning up caches when memory gets tight adds another level of complexity. And so on.

除此之外，每个 slab（由一个或多个连续的页框构成，用于存放待分配的对象）的开头包含一大块元数据（metadata），使得对象更难对齐。以及在内存变得紧张时用于清理缓存的代码使得 slab 分配器的设计变得更加复杂。诸如此类的问题还有很多。

> Christoph's response is the [SLUB allocator](http://lwn.net/Articles/229096/), a drop-in replacement for the slab code. SLUB promises better performance and scalability by dropping most of the queues and related overhead and simplifying the slab structure in general, while retaining the current slab allocator interface.

Christoph 提供的解决之道是 [SLUB 分配器](http://lwn.net/Articles/229096/)，并希望它成为 slab 分配器的直接替代品。SLUB 通过去除了大部分的队列和相关的开销，整体上简化了 slab 的数据机构，可以提供更好的性能和伸缩性，同时保留当前的 slab 分配器的调用接口。

> In the SLUB allocator, a slab is simply a group of one or more pages neatly packed with objects of a given size. There is no metadata within the slab itself, with the exception that free objects are formed into a simple linked list. When an allocation request is made, the first free object is located, removed from the list, and returned to the caller.

在SLUB分配器中，slab只是一组一个或多个页面，整齐地包含给定大小的对象。slab本身没有元数据，除了free对象形成一个简单的链表。在发出分配请求时，将找到第一个空闲对象，从列表中删除该对象并返回给调用者。

> Given the lack of per-slab metadata, one might well wonder just how that first free object is found. The answer is that the SLUB allocator stuffs the relevant information into the system memory map - the `page` structures associated with the pages which make up the slab. Making `struct page` larger is frowned upon in a big way, so the SLUB allocator makes this complicated structure even more so with the addition of another union. The end result is that `struct page` gets three new fields which only have meaning when the associated page is part of a slab:

SLUB 设计中不再对每个板块维护自身的元数据（metadata），人们不禁会问内核是如何找到第一个空闲的对象的呢。答案是 SLUB 分配器将相关信息保存在系统的内存映射表中，即那些组成 slab 的页框所对应的 `page` 结构体中。任何会导致 `struct page` 变大的改动都得小心，SLUB 分配器通过使用联合（union）的方式使得这个原本就复杂的结构体变得更加复杂了。最终的结果是 `struct page` 中增加了三个新的字段，这些字段仅在该页框成为 slab 的一部分时才有意义：

	void *freelist;
	short unsigned int inuse;
	short unsigned int offset;

> For slab use, `freelist` points to the first free object within a slab, `inuse` is the number of objects which have been allocated from the slab, and `offset` tells the allocator where to find the pointer to the next free object. The SLUB allocator can use RCU to free objects, but, to do so, it must be able to put the "next object" pointer outside of the object itself; the `offset` pointer is the allocator's way of tracking where that pointer was put.

`freelist` 用于指向该 slab 中的第一个空闲的对象，`inuse` 用于记录该 slab 中已经分配的对象的数量，`offset` 告诉分配器到哪里可以找到指向下一个空闲对象的指针。SLUB 分配器使用 RCU 释放对象，为此，它必须将指向 “下一个对象” 的指针放在存放该对象本身的内存空间之外；根据该 `offset` 分配器可以计算得到存放该指针的位置。

> When a slab is first created by the allocator, it has no objects allocated from it. Once an object has been allocated, it becomes a "partial" slab which is stored on a list in the `kmem_cache` structure. Since this is a patch aimed at scalability, there is, in fact, one "partial" list for each NUMA node on the system. The allocator tries to keep allocations node-local, but it will reach across nodes before filling the system with partial slabs.

当分配器首次创建 slab 时，还没有从中分配对象。一旦分配了一个对象，它就变成了一个 “partial” 类型的 slab，`kmem_cache` 结构体的变量中包含有一个链表用于维护该类型的 slab。考虑到可扩展性，该补丁实际上为 NUMA 系统上的每个节点（node）都维护一个 “partial” 类型的链表。分配器总是先尝试分配节点自己本地的内存，但一旦本地内存全部分配为 partial 类型的 slab 后，它也会尝试跨节点分配。

> There is also a per-CPU array of active slabs, intended to prevent cache line bouncing even within a NUMA node. There is a special thread which runs (via a workqueue) which monitors the usage of per-CPU slabs; if a per-CPU slab is not being used, it gets put back onto the partial list for use by other processors.

补丁为每个处理器预留了一个 slab 的数组（per-CPU slabs），其目的是为了预防 NUMA 节点内部各个处理器之间发生所谓的 “缓存弹跳（cache line bouncing）” 问题。为此特地运行一个特殊的线程（通过工作队列的方式）监视每个 CPU 对预留 slab 的使用情况；如果发现有空闲的 slab，则将其回收后放到 partial 链表中供其他处理器使用。

> If all objects within a slab are allocated, the allocator simply forgets about the slab altogether. Once an object in a full slab is freed, the allocator can relocate the containing slab via the system memory map and put it back onto the appropriate partial list. If all of the objects within a given slab (as tracked by the `inuse` counter) are freed, the entire slab is given back to the page allocator for reuse.

如果一个 slab 中所有的对象都被分配了（译者注，即成为 full slab），则分配器会将其从 partial 链表中移除该 slab（译者注，和 slab 分配器不同的是， SLUB 分配器并没有为 full 类型的 slab 维护另一个链表，所以原文中说 ` the allocator simply forgets about the slab altogether`）。一旦一个 full slab 中有对象被归还，分配器通过系统内存映射表重新定位该 slab 并将其放回到相应的 partial 链表中。如果一个 slab 中的所有对象都被归还了（由 `inuse` 计数器负责跟踪），则将整个 slab 返还给页框分配器以便下次继续使用。

> One interesting feature of the SLUB allocator is that it can combine slabs with similar object sizes and parameters. The result is fewer slab caches in the system (a 50% reduction is claimed), better locality of slab allocations, and less fragmentation of slab memory. The patch does note:

SLUB分配器的一个有趣特性是它可以将具有相似对象大小和参数的平板组合在一起。结果是系统中较少的slab缓存（声称减少了50％），slab分配的更好局部性以及slab内存的更少碎片。补丁注意到：

> 	Note that merging can expose heretofore unknown bugs in the kernel because corrupted objects may now be placed differently and corrupt differing neighboring objects. Enable sanity checks to find those.

	请注意，合并可能会暴露内核中迄今未知的错误，因为现在可能会以不同方式放置损坏的对象并破坏不同的相邻对象。启用完整性检查以查找这些。

> Causing bugs to stand out is generally considered to be a good thing, but wider use of the SLUB allocator could lead to some quirky behavior until those new bugs are stamped out.

通常认为导致漏洞脱颖而出是一件好事，但更广泛地使用SLUB分配器可能会导致一些奇怪的行为，直到这些新漏洞被淘汰。

> Wider use may be in the cards: the SLUB allocator is in the -mm tree now and could hit the mainline as soon as 2.6.22. The simplified code is attractive, as is the claimed 5-10% performance increase. If merged, SLUB is likely to coexist with the current slab allocator (and the SLOB allocator intended for small systems) for some time. In the longer term, the current slab code may be approaching the end of its life.

更广泛的使用可能在卡片中：SLUB分配器现在位于-mm树中，并且可以在2.6.22时立即到达主线。简化的代码很有吸引力，声称的性能提升5-10％。如果合并，SLUB可能会与当前的slab分配器（以及用于小型系统的SLOB分配器）共存一段时间。从长远来看，目前的板坯代码可能接近其寿命终点。

[1]: http://tinylab.org
