---
layout: post
author: 'Wang Chen'
title: "LWN 229984: SLUB 分配器"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-229984-slub-allocator/
description: "LWN 文章翻译，SLUB 分配器"
category:
  - 内存子系统
  - LWN
tags:
  - Linux
  - memory
---

> 原文：[The SLUB allocator](https://lwn.net/Articles/229984/)
> 原创：By corbet @ Apr. 11, 2007
> 翻译：By [unicornx](https://github.com/unicornx) of [TinyLab.org][1]
> 校对：By [xxx](https://github.com/xx)

> The slab allocator has been at the core of the kernel's memory management for many years. This allocator (sitting on top of the low-level page allocator) manages caches of objects of a specific size, allowing for fast and space-efficient allocations. Kernel hackers tend not to wander into the slab code because it's complex and because, for the most part, it works quite well.

slab 分配器（slab allocator，译者注，“slab” 的含义来自于英语中的 “石板” 的概念）多年来一直是内核中内存管理子系统的核心模块。该分配器（位于底层基于页框的分配器之上）对特定大小的内存对象的分配和回收进行管理并提供高速缓存，供使用者对其快速的访问，同时节省了内存的空间（译者注，考虑一下如果没有 slab 分配器，只基于底层的页框分配机制，我们对任何一个不大于页框大小（譬如 4K）的内存请求，都只能按最小 4K 大小分配内存那会是多么浪费的一件事情）。内核开发人员一般不会尝试去修改 slab 的相关代码，一来是因为它的确很复杂，二来也是因为在大多数情况下，它运行得很好。

> Christoph Lameter is one of those people for whom the slab allocator does not work quite so well. Over time, he has come up with a list of complaints that is getting impressively long. The slab allocator maintains a number of queues of objects; these queues can make allocation fast but they also add quite a bit of complexity. Beyond that, the storage overhead tends to grow with the size of the system:

但再好的东西也会有人发现它的缺点，Christoph Lameter 就是这么一位内核极客。在使用过程中，他总结了一份令人印象深刻的问题清单。其中最值得大家关注的是，slab 分配器维护了许多保存对象的队列；这些队列可以加速对象的分配，但也带来了诸多复杂性。除此之外，随着系统的规模变大，slab 分配器消耗的内存开销也趋于变大，以下摘录了 Christoph Lameter 总结的问题描述：

> 	SLAB Object queues exist per node, per CPU. The alien cache queue even has a queue array that contain a queue for each processor on each node. For very large systems the number of queues and the number of objects that may be caught in those queues grows exponentially. On our systems with 1k nodes / processors we have several gigabytes just tied up for storing references to objects for those queues This does not include the objects that could be on those queues. One fears that the whole memory of the machine could one day be consumed by those queues.

	每个节点（node，译者注，[NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access) 的概念）中的每个 CPU 使用队列管理自己的 SLAB 对象。外部节点的缓存（alien cache queue）中甚至保存了一个队列数组，对每个外部节点上的每个处理器也都维护了一个队列。对于一个规模巨大的系统，队列的数量和可能保存在这些队列中的对象的数量呈指数增长。在我们的具有 1000 个节点或者同等规模处理器数量的系统上，我们光为了保存这些队列中对对象的引用就需要耗费掉几千兆字节。这还不包括用于存储实际对象的空间。人们担心机器的整个存储空间总有一天会被这些队列消耗殆尽。

> Beyond that, each slab (a group of one or more continuous pages from which objects are allocated) contains a chunk of metadata at the beginning which makes alignment of objects harder. The code for cleaning up caches when memory gets tight adds another level of complexity. And so on.

除此之外，每个slab（一组一个或多个从中分配对象的连续页面）在开头包含一大块元数据，这使得对象更难对齐。当内存变得紧张时清理缓存的代码增加了另一个复杂程度。等等。

> Christoph's response is the [SLUB allocator](http://lwn.net/Articles/229096/), a drop-in replacement for the slab code. SLUB promises better performance and scalability by dropping most of the queues and related overhead and simplifying the slab structure in general, while retaining the current slab allocator interface.

Christoph的响应是SLUB分配器，它是slab代码的直接替代品。SLUB承诺提供更好的性能和可伸缩性，通过丢弃大部分队列和相关开销并简化板块结构，同时保留当前的slab分配器接口。

> In the SLUB allocator, a slab is simply a group of one or more pages neatly packed with objects of a given size. There is no metadata within the slab itself, with the exception that free objects are formed into a simple linked list. When an allocation request is made, the first free object is located, removed from the list, and returned to the caller.

在SLUB分配器中，slab只是一组一个或多个页面，整齐地包含给定大小的对象。slab本身没有元数据，除了free对象形成一个简单的链表。在发出分配请求时，将找到第一个空闲对象，从列表中删除该对象并返回给调用者。

> Given the lack of per-slab metadata, one might well wonder just how that first free object is found. The answer is that the SLUB allocator stuffs the relevant information into the system memory map - the page structures associated with the pages which make up the slab. Making struct page larger is frowned upon in a big way, so the SLUB allocator makes this complicated structure even more so with the addition of another union. The end result is that struct page gets three new fields which only have meaning when the associated page is part of a slab:

鉴于缺少每个板块的元数据，人们可能会想知道如何找到第一个自由对象。答案是SLUB分配器将相关信息填充到系统内存映射中 - 与 构成slab 的页面相关联的页面结构。使 结构页面变大是一件大事，因此SLUB分配器通过添加另一个联合使得这种复杂的结构变得更加复杂。最终结果是struct页面获得三个新字段，这些字段仅在关联页面是slab的一部分时才有意义：

	void *freelist;
	short unsigned int inuse;
	short unsigned int offset;

> For slab use, freelist points to the first free object within a slab, inuse is the number of objects which have been allocated from the slab, and offset tells the allocator where to find the pointer to the next free object. The SLUB allocator can use RCU to free objects, but, to do so, it must be able to put the "next object" pointer outside of the object itself; the offset pointer is the allocator's way of tracking where that pointer was put.

对于slab使用，freelist指向slab 中的第一个自由对象，inuse是从slab分配的对象的数量，offset指示分配器在哪里找到指向下一个自由对象的指针。SLUB分配器可以使用RCU释放对象，但是，为此，它必须能够将“下一个对象”指针放在对象本身之外; 该偏移指针跟踪的分配的方式，其中该指针被送到了。

> When a slab is first created by the allocator, it has no objects allocated from it. Once an object has been allocated, it becomes a "partial" slab which is stored on a list in the kmem_cache structure. Since this is a patch aimed at scalability, there is, in fact, one "partial" list for each NUMA node on the system. The allocator tries to keep allocations node-local, but it will reach across nodes before filling the system with partial slabs.

当分配器首次创建slab时，它没有从中分配对象。一旦分配了一个对象，它就变成了一个“部分”slab，它存储在kmem_cache结构的列表中。由于这是一个针对可扩展性的补丁，实际上，系统上的每个NUMA节点都有一个“部分”列表。分配器尝试保持节点本地分配，但在使用部分平板填充系统之前，它将到达节点。

> There is also a per-CPU array of active slabs, intended to prevent cache line bouncing even within a NUMA node. There is a special thread which runs (via a workqueue) which monitors the usage of per-CPU slabs; if a per-CPU slab is not being used, it gets put back onto the partial list for use by other processors.

还有一个每CPU的活动板阵列，旨在防止缓存线在NUMA节点内反弹。有一个特殊的线程运行（通过工作队列）监视每个CPU板的使用情况; 如果没有使用每个CPU平板，它将被放回到部分列表中供其他处理器使用。

> If all objects within a slab are allocated, the allocator simply forgets about the slab altogether. Once an object in a full slab is freed, the allocator can relocate the containing slab via the system memory map and put it back onto the appropriate partial list. If all of the objects within a given slab (as tracked by the inuse counter) are freed, the entire slab is given back to the page allocator for reuse.

如果分配了slab中的所有对象，则分配器只会完全忘记slab。一旦释放了一个完整slab中的对象，分配器就可以通过系统内存映射重新定位包含的slab并将其放回到相应的部分列表中。如果释放给定slab中的所有对象（由inuse计数器跟踪），则将整个slab返回给页面分配器以供重用。

> One interesting feature of the SLUB allocator is that it can combine slabs with similar object sizes and parameters. The result is fewer slab caches in the system (a 50% reduction is claimed), better locality of slab allocations, and less fragmentation of slab memory. The patch does note:

SLUB分配器的一个有趣特性是它可以将具有相似对象大小和参数的平板组合在一起。结果是系统中较少的slab缓存（声称减少了50％），slab分配的更好局部性以及slab内存的更少碎片。补丁注意到：

> 	Note that merging can expose heretofore unknown bugs in the kernel because corrupted objects may now be placed differently and corrupt differing neighboring objects. Enable sanity checks to find those.

	请注意，合并可能会暴露内核中迄今未知的错误，因为现在可能会以不同方式放置损坏的对象并破坏不同的相邻对象。启用完整性检查以查找这些。

> Causing bugs to stand out is generally considered to be a good thing, but wider use of the SLUB allocator could lead to some quirky behavior until those new bugs are stamped out.

通常认为导致漏洞脱颖而出是一件好事，但更广泛地使用SLUB分配器可能会导致一些奇怪的行为，直到这些新漏洞被淘汰。

> Wider use may be in the cards: the SLUB allocator is in the -mm tree now and could hit the mainline as soon as 2.6.22. The simplified code is attractive, as is the claimed 5-10% performance increase. If merged, SLUB is likely to coexist with the current slab allocator (and the SLOB allocator intended for small systems) for some time. In the longer term, the current slab code may be approaching the end of its life.

更广泛的使用可能在卡片中：SLUB分配器现在位于-mm树中，并且可以在2.6.22时立即到达主线。简化的代码很有吸引力，声称的性能提升5-10％。如果合并，SLUB可能会与当前的slab分配器（以及用于小型系统的SLOB分配器）共存一段时间。从长远来看，目前的板坯代码可能接近其寿命终点。

[1]: http://tinylab.org
