---
layout: post
author: 'Wang Chen'
title: "LWN 228143: 可延迟定时器（Deferrable timers）"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-228143-deferrable-timers/
description: "LWN 文章翻译，可延迟定时器（Deferrable timers）"
category:
  - 时钟系统
  - LWN
tags:
  - Linux
  - timer
---

> 原文：[Deferrable timers](https://lwn.net/Articles/228143/)
> 原创：By corbet @ March 28, 2007
> 翻译：By [unicornx](https://github.com/unicornx) of [TinyLab.org][1]
> 校对：By [guojian-at-wowo](https://github.com/guojian-at-wowo)

> The [dynamic tick](http://lwn.net/Articles/223185/) code featured in the upcoming 2.6.21 kernel seeks to avoid processor wakeups by turning off the period timer tick when nothing is happening. Before stopping the clock, the kernel must decide when it should wake up again; this decision involves looking at the timer queue to see when the next timer expires. In the absence of other events (hardware interrupts, for example), the system will sleep until the nearest timer is due.

在即将发布的 2.6.21 版本内核中引入了一个新功能 [动态时钟（dynamic tick）](http://lwn.net/Articles/223185/)，dynamic tick 支持在系统空闲时关闭周期定时器时钟中断从而避免频繁唤醒休眠的处理器。在停止时钟中断之前，内核必须决定何时再次唤醒系统；为此内核需要检查定时器队列（timer queue），查看下一个到期的定时器的到期时间。如果没有其他的硬件中断事件的话，系统会一直休眠，直到最近的定时器到期才会被唤醒。

> Many of these timers should, in fact, run as soon as the requested period has expired. Others, however, are less important - to the point that they are not worth waking up the processor. These non-critical timeouts can run some fraction of a second later (when the processor wakes up for other reasons) and nobody will notice the difference. So it would be nice if there were a way to tell the kernel that a specific timer does not require immediate action on expiration and that the processor should not wake up for the sole purpose of handling it.

这些定时器中的大部分都应该在请求的期限到期后立即被触发运行。但总是存在一些定时器，没有那么重要，不需要立即唤醒处理器来处理它们。这些超时事件没有那么关键，完全可以在到期后的几分之一秒（当处理器因其他原因而被唤醒时）再被处理，关键是其用户并不会在意这微小的差异。所以如果有一种方法可以告诉内核对这些特殊的定时器在到期时可以暂缓唤醒处理器并采取行动，那对节能将是一件多么有意义的事情啊。

> Venki Pallipadi has created such a way with the [deferrable timers patch](https://lwn.net/Articles/228147/). There is just one new function added to the internal kernel API:

Venki Pallipadi 提供了一种方法解决了这个问题，具体参考他提交的[可延迟定时器（deferrable timers）补丁](https://lwn.net/Articles/228147/)。对使用者来说只需要了解该补丁增加了一个内部的编程接口函数：

    void init_timer_deferrable(struct timer_list *timer);

> Timers which are initialized in this fashion will be recognized as deferrable by the kernel. They will not be considered when the kernel makes its "when should the next timer interrupt be?" decision. When the system is busy these timers will fire at the scheduled time. When things are idle, instead, they will simply wait until something more important wakes up the processor.

以这种方式初始化的定时器将被内核认是可以延迟执行的。内核在计算 “下一次定时器中断的时间” 时，将忽略这些定时器。当系统繁忙时，这些定时器和原先一样正常触发。当系统空闲时，他们会一直等到有其他更重要的事情唤醒处理器时才会一起被触发执行。

> Venki appears to have gone to great length to minimize the changes required by this patch. So, in particular, the `timer_list` structure does not change at all. Instead, the low-order bit on an internal pointer (which is known to always be zero) is repurposed as a "deferrable" flag. The result is that the `timer_list` structure does not grow to support this new functionality, at the cost of requiring all code using the internal `base` pointer to mask out the "deferrable" bit.

Venki 已经竭尽全力将这个补丁所涉及到的修改降至最低。`timer_list` 结构体基本没有改动。只是复用了它的一个内部指针成员的最低位作为标志来标识“是否可推迟”，而且至少目前来看该指针成员并没有人用过，其值始终为零（译者注：内部指针成员即 `timer_list` 的 `base` ）。这么做的好处是该补丁修改保持了 `timer_list` 结构体大小不变，但代价是要求所有涉及该 `base` 指针的代码在使用该指针前需要先屏蔽掉该标志位。

> The patch, as presented, only affects timers used within the kernel; no code has been changed to actually use deferrable timers yet. There could be potential in extending this interface somehow to user space. Our user space remains full of applications which feel the need to wake up frequently to check the state of the world; these applications are a real problem for power-limited systems. If those applications truly cannot be fixed, perhaps they could at least indicate a willingness to wait when nothing important is going on.

如前所述，该补丁只影响内核中对定时器的使用；而且目前还没有人实际使用定时器的可延迟特性。在某种程度上来说可以将这个接口扩展到用户空间。我们的用户空间中有很多代码会频繁唤醒系统并执行一些检查；这对于功率受限的系统来说是一个真正的问题。如果这些应用程序不愿意修改实现逻辑，那么或许它们至少可以表明在没有重要事件发生时愿意等待。

[1]: http://tinylab.org
