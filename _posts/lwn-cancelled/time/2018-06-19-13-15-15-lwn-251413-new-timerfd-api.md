---
layout: post
author: 'Wang Chen'
title: "LWN 251413: 新的 `timerfd()` 编程接口"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-251413-new-timerfd-api/
description: "LWN 文章翻译，新的 `timerfd()` 编程接口"
category:
  - 时钟系统
  - LWN
tags:
  - Linux
  - timer
---

> 原文：[The new timerfd() API](https://lwn.net/Articles/251413/)
> 原创：By corbet @ Sept. 25, 2007
> 翻译：By [unicornx](https://github.com/unicornx) of [TinyLab.org][1]
> 校对：By [guojian-at-wowo](https://github.com/guojian-at-wowo)

> The `timerfd()` system call was added in the 2.6.22 kernel. The core idea behind `timerfd()` - allowing a process to associate a file descriptor with timer events - is not controversial, but the implementation of this idea did, belatedly, [raise a few eyebrows](http://lwn.net/Articles/245533/). In particular, Michael Kerrisk pointed out that `timerfd()` was inconsistent with (and less powerful than) the existing timer-related system calls, and, besides, the 2.6.22 version did not even work as advertised. After a fair amount of discussion, it became clear that the issues with this system call would not be worked out in the 2.6.23 time frame. So the 2.6.23-rc7 prepatch disabled `timerfd()` altogether in an attempt to prevent application developers from using an API which is going to change.

2.6.22 版本的内核中增加了一个新的系统调用 `timerfd()`。其主要用途是允许进程通过文件描述符获取定时器事件通知，针对该功能本身大家并没有什么争议，引发社区关注的主要是有关该系统调用的具体实现。特别地，Michael Kerrisk 指出，在提供的功能上，`timerfd()` 无法覆盖现有的其他定时器相关的系统调用函数所提供的功能，此外，在 2.6.22 版本中该系统调用的行为和其宣称所提供的能力也不一致。经过深入讨论后，社区确定，考虑到由于这个系统调用的问题来不及在 2.6.23 版本中解决。所以，在 2.6.23-rc7 集成版本中先禁用了 `timerfd()`，以确保应用程序开发人员在该系统调用接口整改完毕之前不要使用它。

> Prompted by all of this, Davide Libenzi (the creator of the original `timerfd()` system call) has posted [a proposal for a revised timerfd() API](http://lwn.net/Articles/251227/). The single system call has turned into three different calls with a few new features.

Davide Libenzi（`timerfd()` 系统调用的创建者）已经提交了[改进建议](http://lwn.net/Articles/251227/)。原来的一个系统调用现在拆分为三个，同时添加了一些新功能。

> Under the new API, an application wanting to create a file descriptor for timer events would make a call to:

基于新的接口，一个应用程序可以通过调用如下函数创建一个定时器对象，同时返回一个与之关联的文件描述符：

    int timerfd_create(int clockid);

> Where `clockid` describes which clock should be used; it will be either `CLOCK_MONOTONIC` or `CLOCK_REALTIME`. The return value will, if all goes well, be the requested file descriptor.

“clockid” 参数用于指定时钟基准；可以是 `CLOCK_MONOTONIC` 或 `CLOCK_REALTIME`。如果一切顺利，返回值是请求的文件描述符。

> A timer event can be requested with:

启动定时器事件可以通过以下函数：

    int timerfd_settime(int fd, int flags, const struct itimerspec *timer,
			struct itimerspec *previous);

> Here, `fd` is a file descriptor obtained from `timerfd_create()`, and `timer` gives the desired expiration time (and re-arming interval value, if desired). This time is normally a relative time, but if the timer sets the `TFD_TIMER_ABSTIME` bit in `flags`, it will be interpreted as an absolute time instead. If `previous` is not NULL, the pointed-to structure will be filled with the previous value of the timer. This ability to obtain the previous value is one of the features which was lacking in the original `timerfd()` implementation.

这里，`fd` 是 `timerfd_create()` 返回的文件描述符，参数 `timer` 用于指定首次到期的时间（如果需要，还可以指定第一次到期后继续周期性触发的间隔值）。缺省情况下指定的值是相对时间，如果在 `flags` 参数中设置了 `TFD_TIMER_ABSTIME` 位，则被解释为绝对时间。如果 `previous` 非空（NULL），则其所指向的结构体变量在函数返回时会被填充为上一次定时器设置的值。这种获取前一个值的能力是原来的 `timerfd()` 接口所不具备的。

> That implementation also had no way for an application to simply ask what the current value of the timer was. The new API provides a function for querying a timer non-destructively:

原接口（译者注：指 `timerfd()`）也不支持应用程序简单地询问定时器的当前设置。从完备性出发，新的接口定义了一个新函数可以查询定时器的设置：

    int timerfd_gettime(int fd, struct itimerspec *timer);

> This system call will store the current expiration time (if any) associated with `fd` into `timer`.

这个系统调用会将与 `fd` 关联的定时器的当前到期时间（如果有）保存到 `timer` 所指向的结构体变量中返回给用户。

> The `read()` interface is essentially unchanged. A process which reads on a timer file descriptor will block if the timer has not yet expired. It will then read a 64-bit integer value indicating how many times the timer has expired since it was last read. A timer file descriptor can be passed to `poll()`, allowing timers to be handled in an applications main event loop.

`read()` 接口的使用保持不变。如果定时器尚未过期，则读取该定时器对应的文件描述符的进程将阻塞。读取的结果通过一个 64 位的整数值返回，表示自上次读取以来定时器过期的次数。定时器对应的文件描述符可以传递给 `poll()`，方便应用程序在循环中对定时器事件进行轮询。

> Responses to the new API proposal have been muted at best; hopefully this silence means that developers are happy with the new system calls. The alternative is that this iteration of `timerfd()` will not be reviewed any more extensively than its predecessor was. As things stand, the new set of system calls looks likely to be merged for 2.6.24.

社区对新接口的反应很平静；希望这意味着大家对新的系统调用还是感到满意的。这也可以被理解为针对 `timerfd()` 的新的修改迭代不会像它的上一个版本那样招致如此多的抱怨。就目前来看，这组新的系统调用很有可能会被 2.6.24 版本的内核所接纳（译者注，该补丁最终是在 2.6.25 版本中被合入）。

[1]: http://tinylab.org
