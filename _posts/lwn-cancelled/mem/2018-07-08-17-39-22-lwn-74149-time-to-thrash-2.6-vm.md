---
layout: post
author: 'Wang Chen'
title: "LWN 74149: xxxx"
album: 'LWN 中文翻译'
group: translation
license: "cc-by-sa-4.0"
permalink: /lwn-74149-time-to-thrash-2.6-vm/
description: "LWN 文章翻译，xxxx"
category:
  - 内存子系统
  - LWN
tags:
  - Linux
  - memory
---

> 原文：[Time to thrash the 2.6 VM?](https://lwn.net/Articles/74149/)
> 原创：By corbet @ Mar. 3, 2004
> 翻译：By [unicornx](https://github.com/unicornx) of [TinyLab.org][1]
> 校对：By [???](https://github.com/???)

> Those who have been watching kernel development for a little while will remember [the fun](http://lwn.net/2001/0927/kernel.php3) that came with the 2.4.10 release, when Linus replaced the virtual memory subsystem with a new implementation by Andrea Arcangeli. The 2.4 kernel did end up with a stable VM some releases thereafter, but many developers were upset that such a major change would be merged that far into a stable series. Especially since many of those developers were not convinced that the previous VM was not fixable.

那些一直关注内核开发的人会记住2.4.10版本带来的乐趣，当时Linus用Andrea Arcangeli的新实现替换了虚拟内存子系统。2.4内核之后确实最终得到了一个稳定的VM，但是很多开发人员都很不高兴这样一个重大变化将被合并到一个稳定的系列中。特别是因为许多开发人员不相信以前的VM无法修复。
 
> The 2.4 changes are long past, but the memories are fresh enough that when Andrea put forward [a set of VM changes](https://lwn.net/Articles/73367/) which, while they are for 2.4, are said to be applicable to 2.6 as well, people took notice. Andrea's goals this time are little more focused; he is concerned with the performance of systems with at least 32GB of installed memory and hundreds of processes with shared mappings of large files. This, of course, is the sort of description that might fit a high-end database server.

2.4的变化早已过去，但记忆很新鲜，当Andrea提出一组VM更改时 ，虽然它们是2.4，但据说也适用于2.6，人们注意到了。这次安德里亚的目标更加集中; 他关注的是具有至少32GB已安装内存的系统的性能以及数百个具有大型文件共享映射的进程。当然，这是可能适合高端数据库服务器的那种描述。

> Andrea has found three problems which make those massive servers fail to function well. The first has to do with how 2.4 performs swapout; it works by scanning each process's virtual address space, and unmapping pages that it would like to make free. When a page's mapping count reaches zero, it gets kicked out of main memory. The problem is that this algorithm performs poorly in situations where many processes have the same, large file mapped. The VM will start by unmapping the entire file for the first process, then another, and so on. Only when it has passed through all of the processes mapping the file can it actually move pages out of main memory. Meanwhile, all of those processes are incurring minor page faults and remapping the pages. With enough memory and processes, the VM subsystem is almost never able to actually free anything.

安德里亚发现了三个问题，使这些大型服务器无法正常运行。第一个与2.4如何执行换出有关; 它的工作原理是扫描每个进程的虚拟地址空间，并取消它想要释放的页面。当页面的映射计数达到零时，它将被踢出主内存。问题是该算法在许多进程具有相同的大文件映射的情况下表现不佳。VM将首先取消映射第一个进程的整个文件，然后取消另一个进程，依此类推。只有当它通过映射文件的所有进程时才能实际将页面移出主存。同时，所有这些进程都会出现轻微的页面错误并重新映射页面。有足够的内存和进程，

> This is the problem that the reverse-mapping VM (rmap) was added to 2.5 to solve. By working directly with physical pages and following pointers to the page tables which map them, the VM subsystem can quickly free pages for other use. Andrea is critical of rmap, however; with his scenario of 32GB of memory and hundreds of processes, the rmap infrastructure grows to a point where the system collapses. Instead, for his patches, he has implemented a variant of the [object-based reverse mapping](https://lwn.net/Articles/23732/) scheme. Object-based reverse mapping works by following the links from the object (a shared file, say) which backs up the shared memory; in this way it is able to dispense with the rmap structures in many situations. There are some concerns about pathological performance issues with the object-based approach, but those problems do not seem to arise in real-world use.

这是将反向映射VM（rmap）添加到2.5以解决的问题。通过直接处理物理页面并跟随指向映射它们的页面表的指针，VM子系统可以快速释放页面以供其他用途。然而，Andrea对rmap持批评态度; 在他的32GB内存和数百个进程的情况下，rmap基础架构发展到了系统崩溃的程度。相反，对于他的补丁，他已经实现了基于对象的反向映射的变体方案。基于对象的反向映射通过跟踪来自备份共享内存的对象（例如共享文件）的链接来工作; 通过这种方式，它可以在许多情况下省去rmap结构。对基于对象的方法存在一些关于病理性能问题的担忧，但这些问题似乎并未出现在实际使用中。

> The second problem is a simple bug in the swapout code. When shared memory is unmapped and set up for swap, the actual I/O to write it out to the swap file is not started right away. By the time the system gets around to actually performing I/O, there is a huge pile of pages waiting to be shoved out, and an I/O storm results. Even then, the way the kernel tracks this memory means that it takes a long time to notice that it is free even after it has been written to swap. This problem is fixed by taking frequent breaks to actually shove dirty memory out to disk.

第二个问题是交换代码中的一个简单错误。当共享内存未映射并设置为交换时，不会立即启动将其写入交换文件的实际I / O. 当系统实际执行I / O时，有一大堆页面等待推出，并产生I / O风暴。即使这样，内核跟踪这个内存的方式意味着即使在写入交换之后它也需要很长时间才能注意到它是免费的。通过频繁中断实际将脏内存推送到磁盘来解决此问题。

> Andrea's final problem came about when he tried to copy a large file while all those database processes were running. It turns out that the system was swapping out the shared database memory (which was dirty and in use) rather than the data from the file just copied (which is clean). Tweaking the memory freeing code to make it prefer clean cache pages over dirty pages straightened this problem out, at the cost of a certain amount of unfairness.

当Andrea尝试在所有这些数据库进程运行时复制大文件时，最终出现了问题。事实证明，系统正在交换共享数据库内存（它是脏的并且正在使用中）而不是刚刚复制的文件中的数据（这是干净的）。调整内存释放代码以使其更喜欢在脏页面上清理缓存页面，以一定程度的不公平为代价来解决这个问题。

> With these patches, Andrea claims, the 2.4 kernel can run heavy loads on large systems which will immediately lock up a 2.6 system. So he is going to start looking toward 2.6, with an eye toward beefing it up for this sort of load. Andrew Morton has [indicated](https://lwn.net/Articles/74155/) that he might accept some of this work - but not yet:
 
> 	We need to understand that right now, 2.6.x is 2.7-pre. Once 2.7 forks off we are more at liberty to merge nasty highmem hacks which will die when 2.6 is end-of-lined.
> 	I plan to merge the 4g split immediately after 2.7 forks. I wouldn't be averse to objrmap for file-backed mappings either - I agree that the search problems which were demonstrated are unlikely to bite in real life.

Andrea声称，有了这些补丁，2.4内核可以在大型系统上运行大量负载，这将立即锁定2.6系统。因此他将开始关注2.6，着眼于加强这种负荷。安德鲁莫顿表示他可能会接受一些这项工作 - 但还没有：

	我们现在需要了解，2.6.x是2.7-pre。一旦2.7分叉，我们就可以自由地合并令人讨厌的高手黑客，当2.6终止时，这些黑客会死掉。

	我计划在2.7分叉后立即合并4g分割。对于文件支持的映射，我也不反对objrmap - 我同意所展示的搜索问题在现实生活中不太可能存在。

> The "4g split" is Ingo Molnar's [4GB user-space patch](https://lwn.net/Articles/39925/) which makes more low memory available to the kernel, but at a performance cost. Before Andrew merges any other patches, however, he wants to see a convincing demonstration of why the current VM patches are not enough for large loads. The 2.6 "stable" kernel may well see some significant virtual memory work, but, with luck, it will not be subjected to a 2.4.10-like abrupt switch.

“4g拆分”是Ingo Molnar的4GB用户空间补丁，它可以为内核提供更低的内存，但性能成本却很低。然而，在Andrew合并任何其他补丁之前，他希望看到一个令人信服的演示，说明为什么当前的VM补丁不足以承受大负载。2.6“稳定”内核可能会看到一些重要的虚拟内存工作，但幸运的是，它不会受到类似2.4.10的突然切换。

[1]: http://tinylab.org
